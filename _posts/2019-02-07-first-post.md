---
excerpt: "(1) Pandas 라이브러리 불러오기, (2) 객체 생성, (3) 데이터 확인하기, (4) 데이터 선택적으로 불러오기, (5) 누락된 데이터 확인하기, (6) 기본적인 통계 작업"
header:
  overlay_image: /assets/images/2computers.jpg
  overlay_filter: 0.5 # same as adding an opacity of 0.5 to a black background
  caption: "Photo credit: [**Unsplash**]"
  actions:
    - label: "Reference"
      url: "https://pandas.pydata.org/pandas-docs/stable/getting_started/10min.html "
title: "[Part.1] 초보자를 위한 판다스 (10 Minutes to Pandas!)"
date: 2019-02-07 10:28:28 -0400
categories: python jupyter
tags: pandas
---

## 10 Minutes to pandas
### 초보자를 위한 Pandas 소개
* 자세한 내용은'[cookbook](https://pandas.pydata.org/pandas-docs/stable/user_guide/cookbook.html#cookbook)'참조 
* pandas 0.24.1 documentation


## 1. 라이브러리

```python
import numpy as np
import pandas as pd
```

* 최종 결과뿐만 아니라 모든 Output 출력을 표시하기

```python
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = "all"
```

## 2. 객체 생성
 값 리스트를 전달하여 pandas가 기본 정수 인덱스를 생성하도록 Series 만들기
```python
s = pd.Series([1,3,5, np.nan, 6,8])
s

Out[4]:
0    1.0
1    3.0
2    5.0
3    NaN
4    6.0
5    8.0
dtype: float64
```

 datetime 인덱스와 레이블된 열이 있는 NumPy배열을 전달하여 DataFrame 만들기
```python
dates=pd.date_range('20130101',periods=6)
dates
df=pd.DataFrame(np.random.randn(6,4), index=dates, columns=list('ABCD'))
df

Out[5]:
DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',
               '2013-01-05', '2013-01-06'],
              dtype='datetime64[ns]', freq='D')
Out[5]:
A	B	C	D
2013-01-01	-1.313690	0.374085	0.143973	-0.624099
2013-01-02	-0.659125	-0.595977	0.403210	0.814707
2013-01-03	0.105771	0.338891	-0.404629	0.032208
2013-01-04	0.376774	-0.035958	-0.659694	0.261746
2013-01-05	0.317915	1.052522	-0.794585	1.480261
2013-01-06	0.579203	1.709605	-0.546063	0.336379
```

 직렬로 변환 할 수 있는 개체의 지시를 전달하여 DataFrame 만들기
```python
df2=pd.DataFrame({'A':1.,
                 'B':pd.Timestamp('20130102'),
                 'C':pd.Series(1, index=list(range(4)),dtype='float32'),
                 'D':np.array([3]*4,dtype='int32'),
                 'E':pd.Categorical(["test","train","test","train"]),
                 'F':'foo'})
df2

Out[6]:
A	B	C	D	E	F
0	1.0	2013-01-02	1.0	3	test	foo
1	1.0	2013-01-02	1.0	3	train	foo
2	1.0	2013-01-02	1.0	3	test	foo
3	1.0	2013-01-02	1.0	3	train	foo
```

 DataFrame의 열은 다른 dtypes를 가진다.
```python
df2.dtypes

Out[7]:
A           float64
B    datetime64[ns]
C           float32
D             int32
E          category
F            object
dtype: object
```


## 3. 데이터 확인하기

 프레임의 상단과 하단 부분을 보기

```python
df.head()
df.tail(3) #하단부분 3열만 본다는 뜻

Out[8]:
A	B	C	D
2013-01-01	-1.313690	0.374085	0.143973	-0.624099
2013-01-02	-0.659125	-0.595977	0.403210	0.814707
2013-01-03	0.105771	0.338891	-0.404629	0.032208
2013-01-04	0.376774	-0.035958	-0.659694	0.261746
2013-01-05	0.317915	1.052522	-0.794585	1.480261
Out[8]:
A	B	C	D
2013-01-04	0.376774	-0.035958	-0.659694	0.261746
2013-01-05	0.317915	1.052522	-0.794585	1.480261
2013-01-06	0.579203	1.709605	-0.546063	0.336379
```

 인덱스와 상단 열 표시 (Index, Columns)
```python
df.index
df.columns

Out[9]:
DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',
               '2013-01-05', '2013-01-06'],
              dtype='datetime64[ns]', freq='D')
Out[9]:
Index(['A', 'B', 'C', 'D'], dtype='object')
```

DataFrame.to_numpy()는 기본 데이터의 NumPy표현을 제공합니다. DataFrame에 다른 데이터 유형의 열이 있는 경우 힘든 작업이 될 수 있습니다.

pandas와 NumPy의 근본적인 차이가 있습니다. Numpy 배열에는 전채 배열에 대한 하나의 dtype이 있는 반면, pandas의 DataFrames에는 각각의 열마다 각각의 dtype이 있습니다.

DataFrmae.to_numpy()를 불러오면 pandas는 DataFrame의 모든 dtype을 포함 할 수 있는 NumPy dtype을 찾습니다. object가 바로 모든 값을 아우를 수 있는 dtype이 될 수 있습니다.

모든 부동 소수점 값의 DataFrame인 df 경우 DataFrame.to_numpy()가 빠르며 데이터 복사가 필요하지 않습니다.
* DataFrame.to_numpy()는 index와 column 레이블을 포함하지 않습니다.

```python
df.to_numpy()
df.values

Out[10]:
array([[-1.31368999,  0.37408481,  0.14397347, -0.6240987 ],
       [-0.65912479, -0.59597727,  0.40321046,  0.81470747],
       [ 0.10577142,  0.33889057, -0.40462934,  0.03220843],
       [ 0.37677379, -0.03595848, -0.65969389,  0.26174625],
       [ 0.31791509,  1.05252188, -0.79458461,  1.48026149],
       [ 0.57920326,  1.70960542, -0.54606269,  0.33637945]])
Out[10]:
array([[-1.31368999,  0.37408481,  0.14397347, -0.6240987 ],
       [-0.65912479, -0.59597727,  0.40321046,  0.81470747],
       [ 0.10577142,  0.33889057, -0.40462934,  0.03220843],
       [ 0.37677379, -0.03595848, -0.65969389,  0.26174625],
       [ 0.31791509,  1.05252188, -0.79458461,  1.48026149],
       [ 0.57920326,  1.70960542, -0.54606269,  0.33637945]])
```       

 df2의 DataFrame 은 여러 dtypes을 가지고 있다.
```python
df2.to_numpy()

Out[11]:
array([[1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'],
       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo'],
       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'],
       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo']],
      dtype=object)
```

 describe() 는 데이터의 빠른 통계 요약을 보여준다.
```python
df.describe()

Out[12]:
A	B	C	D
count	6.000000	6.000000	6.000000	6.000000
mean	-0.098859	0.473861	-0.309631	0.383534
std	0.733660	0.811733	0.476770	0.713377
min	-1.313690	-0.595977	-0.794585	-0.624099
25%	-0.467901	0.057754	-0.631286	0.089593
50%	0.211843	0.356488	-0.475346	0.299063
75%	0.362059	0.882913	0.006823	0.695125
max	0.579203	1.709605	0.403210	1.480261
```

 열과 행을 바꾸기 원할 때 df.T를 씁니다.
```python
df.T

Out[13]:
2013-01-01 00:00:00	2013-01-02 00:00:00	2013-01-03 00:00:00	2013-01-04 00:00:00	2013-01-05 00:00:00	2013-01-06 00:00:00
A	-1.313690	-0.659125	0.105771	0.376774	0.317915	0.579203
B	0.374085	-0.595977	0.338891	-0.035958	1.052522	1.709605
C	0.143973	0.403210	-0.404629	-0.659694	-0.794585	-0.546063
D	-0.624099	0.814707	0.032208	0.261746	1.480261	0.336379
```

 축별 정렬
```python
df.sort_index(axis=1, ascending=False)

Out[14]:
D	C	B	A
2013-01-01	-0.624099	0.143973	0.374085	-1.313690
2013-01-02	0.814707	0.403210	-0.595977	-0.659125
2013-01-03	0.032208	-0.404629	0.338891	0.105771
2013-01-04	0.261746	-0.659694	-0.035958	0.376774
2013-01-05	1.480261	-0.794585	1.052522	0.317915
2013-01-06	0.336379	-0.546063	1.709605	0.579203
```

 값들 정렬
```python
df.sort_values(by='B')

Out[15]:
A	B	C	D
2013-01-02	-0.659125	-0.595977	0.403210	0.814707
2013-01-04	0.376774	-0.035958	-0.659694	0.261746
2013-01-03	0.105771	0.338891	-0.404629	0.032208
2013-01-01	-1.313690	0.374085	0.143973	-0.624099
2013-01-05	0.317915	1.052522	-0.794585	1.480261
2013-01-06	0.579203	1.709605	-0.546063	0.336379
```


## 4.선택

* 선택 및 설정을 위한 표준 Python/Numpy 표현은 직관적이며 양방향 작업, 프로덕션 코드 용으로 유용하지만 최적화 된 pandas 데이터 액세스 방법인 .at, .iat, .loc 및 .iloc을 권장합니다.

### 가져오기

 df.A와 동등한 Series을 생성하는 단일 열 선택
```python
df['A'] #[열]Column

Out[16]:
2013-01-01   -1.313690
2013-01-02   -0.659125
2013-01-03    0.105771
2013-01-04    0.376774
2013-01-05    0.317915
2013-01-06    0.579203
Freq: D, Name: A, dtype: float64
```

 [ ]을 통해 행을 선택합니다.
```python
df[0:3] #[행]Row
df['20130102':'20130104']

Out[17]:
A	B	C	D
2013-01-01	-1.313690	0.374085	0.143973	-0.624099
2013-01-02	-0.659125	-0.595977	0.403210	0.814707
2013-01-03	0.105771	0.338891	-0.404629	0.032208
Out[17]:
A	B	C	D
2013-01-02	-0.659125	-0.595977	0.403210	0.814707
2013-01-03	0.105771	0.338891	-0.404629	0.032208
2013-01-04	0.376774	-0.035958	-0.659694	0.261746
```

### 레이블에 따라 선택하기
 레이블에 의하여 값 얻기
```python
df.loc[dates[0]] #[행]

Out[18]:
A   -1.313690
B    0.374085
C    0.143973
D   -0.624099
Name: 2013-01-01 00:00:00, dtype: float64
```

레이블 별로 다중 축 선택하기
```python
df.loc[:, ['A','B']] #[행,열]

Out[19]:
A	B
2013-01-01	-1.313690	0.374085
2013-01-02	-0.659125	-0.595977
2013-01-03	0.105771	0.338891
2013-01-04	0.376774	-0.035958
2013-01-05	0.317915	1.052522
2013-01-06	0.579203	1.709605
```

 레이블 슬라이싱
```python
df.loc['20130102':'20130104',['A','B']]

Out[20]:
A	B
2013-01-02	-0.659125	-0.595977
2013-01-03	0.105771	0.338891
2013-01-04	0.376774	-0.035958
```
```python
df.loc['20130102',['A','B']]

Out[21]:
A   -0.659125
B   -0.595977
Name: 2013-01-02 00:00:00, dtype: float64
```

 스칼라값 얻기
```python
df.loc[dates[0],'A']

Out[22]:
-1.313689989467988
```
 스칼라값 빨리 얻기 (이전 방법과 동일)
```python
df.at[dates[0],'A']

Out[23]:
-1.313689989467988
```

### 위치에 의한 선택

 전달된 정수 위치를 통해 선택
```python
df.iloc[3]

Out[24]:
A    0.376774
B   -0.035958
C   -0.659694
D    0.261746
Name: 2013-01-04 00:00:00, dtype: float64
```

 numpy/python과 유사한 interger slices
```python
df.iloc[3:5, 0:2]   #[행,열]

Out[25]:
A	B
2013-01-04	0.376774	-0.035958
2013-01-05	0.317915	1.052522
numpy/python 스타일과 비슷한 정수 위치 리스트
```
```python
df.iloc[[1,2,4],[0,2]]

Out[26]:
A	C
2013-01-02	-0.659125	0.403210
2013-01-03	0.105771	-0.404629
2013-01-05	0.317915	-0.794585
```

 행을 분할하기
```python
df.iloc[1:3,:]

Out[27]:
A	B	C	D
2013-01-02	-0.659125	-0.595977	0.403210	0.814707
2013-01-03	0.105771	0.338891	-0.404629	0.032208
```

 열을 분할하기
```python
df.iloc[:,1:3]

Out[28]:
B	C
2013-01-01	0.374085	0.143973
2013-01-02	-0.595977	0.403210
2013-01-03	0.338891	-0.404629
2013-01-04	-0.035958	-0.659694
2013-01-05	1.052522	-0.794585
2013-01-06	1.709605	-0.546063
```

 특정한 하나의 값 찾기
```python
df.iloc[1,1]

Out[29]:
-0.5959772742174114
```

 더 빠르게 스칼라 찾기 (전 방법과 동등)
```python
df.iat[1,1]

Out[30]:
-0.5959772742174114
```
### Boolean Indexing

 단일 열의 값을 사용하여 데이터를 선택하기
```python
df[df.A>0]

Out[31]:
A	B	C	D
2013-01-03	0.105771	0.338891	-0.404629	0.032208
2013-01-04	0.376774	-0.035958	-0.659694	0.261746
2013-01-05	0.317915	1.052522	-0.794585	1.480261
2013-01-06	0.579203	1.709605	-0.546063	0.336379
```
 Boolean 조건이 충족되는 DataFrame에서 값을 선택합니다.
```python
df[df>0]

Out[32]:
A	B	C	D
2013-01-01	NaN	0.374085	0.143973	NaN
2013-01-02	NaN	NaN	0.403210	0.814707
2013-01-03	0.105771	0.338891	NaN	0.032208
2013-01-04	0.376774	NaN	NaN	0.261746
2013-01-05	0.317915	1.052522	NaN	1.480261
2013-01-06	0.579203	1.709605	NaN	0.336379
```

 필터링 기법인 isin() 방법 사용하기
```python
df2=df.copy()
df2['E']=['one','one','two','three','four','three']
df2
df2[df2['E'].isin(['two','four'])]

Out[33]:
A	B	C	D	E
2013-01-01	-1.313690	0.374085	0.143973	-0.624099	one
2013-01-02	-0.659125	-0.595977	0.403210	0.814707	one
2013-01-03	0.105771	0.338891	-0.404629	0.032208	two
2013-01-04	0.376774	-0.035958	-0.659694	0.261746	three
2013-01-05	0.317915	1.052522	-0.794585	1.480261	four
2013-01-06	0.579203	1.709605	-0.546063	0.336379	three
Out[33]:
A	B	C	D	E
2013-01-03	0.105771	0.338891	-0.404629	0.032208	two
2013-01-05	0.317915	1.052522	-0.794585	1.480261	four
```

### 설정하기
 새 열을 설정하면 데이터를 인덱스별로 자동 정렬합니다.
```python
s1=pd.Series([1,2,3,4,5,6],index=pd.date_range('20130102',periods=6))
s1
df['F']=s1

Out[34]:
2013-01-02    1
2013-01-03    2
2013-01-04    3
2013-01-05    4
2013-01-06    5
2013-01-07    6
Freq: D, dtype: int64
```

 레이블별 값 설정
```python
df.at[dates[0],'A']=0
```

 위치별 값 설정
```python
df.iat[0,1]=0
```

 NumPy 배열을 지정하여 설정
```python
df.loc[:,'D']=np.array([5]*len(df))
```

 설정 작업 결과
```python
df

Out[38]:
A	B	C	D	F
2013-01-01	0.000000	0.000000	0.143973	5	NaN
2013-01-02	-0.659125	-0.595977	0.403210	5	1.0
2013-01-03	0.105771	0.338891	-0.404629	5	2.0
2013-01-04	0.376774	-0.035958	-0.659694	5	3.0
2013-01-05	0.317915	1.052522	-0.794585	5	4.0
2013-01-06	0.579203	1.709605	-0.546063	5	5.0
```

 where 작동 설정하기
```python
df2=df.copy()
df2[df2>0]=-df2
df2

Out[39]:
A	B	C	D	F
2013-01-01	0.000000	0.000000	-0.143973	-5	NaN
2013-01-02	-0.659125	-0.595977	-0.403210	-5	-1.0
2013-01-03	-0.105771	-0.338891	-0.404629	-5	-2.0
2013-01-04	-0.376774	-0.035958	-0.659694	-5	-3.0
2013-01-05	-0.317915	-1.052522	-0.794585	-5	-4.0
2013-01-06	-0.579203	-1.709605	-0.546063	-5	-5.0
```
       
## 5. 누락된 데이터
 pandas는 기본적으로 누락된 데이터를 np.nan값을 사용하여 나타냅니다. 이 값들은 계산에 포합되지 않습니다.

 reindex를 통해 지정된 축의 인덱스를 변경/추가/삭제할 수 있습니다.
```python
df1=df.reindex(index=dates[0:4], columns=list(df.columns)+['E'])
df1.loc[dates[0]:dates[1],'E']=1
df1

Out[41]:
A	B	C	D	F	E
2013-01-01	0.000000	0.000000	0.143973	5	NaN	1.0
2013-01-02	-0.659125	-0.595977	0.403210	5	1.0	1.0
2013-01-03	0.105771	0.338891	-0.404629	5	2.0	NaN
2013-01-04	0.376774	-0.035958	-0.659694	5	3.0	NaN
```

 데이터가 누락된 행을 삭제합니다.
```python
df1.dropna(how='any')

Out[42]:
A	B	C	D	F	E
2013-01-02	-0.659125	-0.595977	0.40321	5	1.0	1.0
```

 누락된 데이터를 채웁니다.
```python
df1.fillna(value=5)

Out[43]:
A	B	C	D	F	E
2013-01-01	0.000000	0.000000	0.143973	5	5.0	1.0
2013-01-02	-0.659125	-0.595977	0.403210	5	1.0	1.0
2013-01-03	0.105771	0.338891	-0.404629	5	2.0	5.0
2013-01-04	0.376774	-0.035958	-0.659694	5	3.0	5.0
```

 nan인 값을 boolean mask로 얻기
```python
pd.isna(df1)

Out[45]:
A	B	C	D	F	E
2013-01-01	False	False	False	False	True	False
2013-01-02	False	False	False	False	False	False
2013-01-03	False	False	False	False	False	True
2013-01-04	False	False	False	False	False	True
```

## 6. 작업
### 통계
#### 일반적으로 누락된 데이터는 제외합니다.
 기술적 통계 수행
```python
df.mean()

Out[46]:
A    0.120090
B    0.411514
C   -0.309631
D    5.000000
F    3.000000
dtype: float64
```

 다른 축에서 동일한 작업 #dates별로 평균내기
```python
df.mean(1)

Out[47]:
2013-01-01    1.285993
2013-01-02    1.029622
2013-01-03    1.408007
2013-01-04    1.536224
2013-01-05    1.915170
2013-01-06    2.348549
Freq: D, dtype: float64
```

 차원이 다르고 정렬이 필요한 객체로 작업하기. 
#### 추가로 pandas는 지정된 차원에 따라 자동으로 제공됩니다.
```python
s=pd.Series([1,3,5,np.nan,6,8],index=dates).shift(2) #shift(2)는 series값을 두캄 미룬다는 뜻
s
df.sub(s,axis='index') #df값에서 s를 뺀 것

Out[51]:
2013-01-01    NaN
2013-01-02    NaN
2013-01-03    1.0
2013-01-04    3.0
2013-01-05    5.0
2013-01-06    NaN
Freq: D, dtype: float64
Out[51]:
A	B	C	D	F
2013-01-01	NaN	NaN	NaN	NaN	NaN
2013-01-02	NaN	NaN	NaN	NaN	NaN
2013-01-03	-0.894229	-0.661109	-1.404629	4.0	1.0
2013-01-04	-2.623226	-3.035958	-3.659694	2.0	0.0
2013-01-05	-4.682085	-3.947478	-5.794585	0.0	-1.0
2013-01-06	NaN	NaN	NaN	NaN	NaN
```

### 적용
 데이터에 함수 적용하기
```python
df

Out[53]:
A	B	C	D	F
2013-01-01	0.000000	0.000000	0.143973	5	NaN
2013-01-02	-0.659125	-0.595977	0.403210	5	1.0
2013-01-03	0.105771	0.338891	-0.404629	5	2.0
2013-01-04	0.376774	-0.035958	-0.659694	5	3.0
2013-01-05	0.317915	1.052522	-0.794585	5	4.0
2013-01-06	0.579203	1.709605	-0.546063	5	5.0
```
```python
df.apply(np.cumsum) #누적값
df.apply(lambda x: x.max()-x.min())

Out[52]:
A	B	C	D	F
2013-01-01	0.000000	0.000000	0.143973	5	NaN
2013-01-02	-0.659125	-0.595977	0.547184	10	1.0
2013-01-03	-0.553353	-0.257087	0.142555	15	3.0
2013-01-04	-0.176580	-0.293045	-0.517139	20	6.0
2013-01-05	0.141336	0.759477	-1.311724	25	10.0
2013-01-06	0.720539	2.469082	-1.857787	30	15.0
Out[52]:
A    1.238328
B    2.305583
C    1.197795
D    0.000000
F    4.000000
dtype: float64
```

### 막대그래프
```python
s=pd.Series(np.random.randint(0,7, size=10)) #randit() 함수 정수 랜덤값을 생성해주는 함수
s
s.value_counts() #각 값들 카운트

Out[62]:
0    2
1    4
2    5
3    1
4    0
5    0
6    3
7    4
8    4
9    5
dtype: int32
Out[62]:
4    3
5    2
0    2
3    1
2    1
1    1
dtype: int64
```

### 문자열 처리 (String Methods)
 Series에는 str 속성에 일련의 문자열처리 방법이 있으므로 배열의 각 요소를 쉽게 조작할 수 있습니다. str의 패턴은 보통 정규식을 사용합니다.(경우에 따라 항상 사용하는 경우도 있습니다.)
```python
s=pd.Series(['A','B','C','Aaba','Baca',np.nan, 'CABA','dog','cat'])
s.str.lower()

Out[63]:
0       a
1       b
2       c
3    aaba
4    baca
5     NaN
6    caba
7     dog
8     cat
dtype: object       
```       
       
