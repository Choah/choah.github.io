---
excerpt: "초보자를 위한 판다스!"
header:
  overlay_image: /assets/images/2computers.jpg
  overlay_filter: 0.5 # same as adding an opacity of 0.5 to a black background
  caption: "Photo credit: [**Unsplash**]"
  actions:
    - label: "Reference"
      url: "https://pandas.pydata.org/pandas-docs/stable/getting_started/10min.html "
title: "초보자를 위한 판다스 (10 Minutes to Pandas!)"
date: 2019-02-07 10:28:28 -0400
categories: python jupyter
tags: pandas
---

## 10 Minutes to pandas
### 초보자를 위한 Pandas 소개
* 자세한 내용은'[cookbook](https://pandas.pydata.org/pandas-docs/stable/user_guide/cookbook.html#cookbook)'참조 
* pandas 0.24.1 documentation


## 1. 라이브러리

```python
import numpy as np
import pandas as pd
```

* 최종 결과뿐만 아니라 모든 Output 출력을 표시하기
```python
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = "all"
```

## 2. 객체 생성
#### 값 리스트를 전달하여 pandas가 기본 정수 인덱스를 생성하도록 Series 만들기
```python
s = pd.Series([1,3,5, np.nan, 6,8])
s

Out[4]:
0    1.0
1    3.0
2    5.0
3    NaN
4    6.0
5    8.0
dtype: float64
```

#### datetime 인덱스와 레이블된 열이 있는 NumPy배열을 전달하여 DataFrame 만들기
```python
dates=pd.date_range('20130101',periods=6)
dates
df=pd.DataFrame(np.random.randn(6,4), index=dates, columns=list('ABCD'))
df

Out[5]:
DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',
               '2013-01-05', '2013-01-06'],
              dtype='datetime64[ns]', freq='D')
Out[5]:
A	B	C	D
2013-01-01	-1.313690	0.374085	0.143973	-0.624099
2013-01-02	-0.659125	-0.595977	0.403210	0.814707
2013-01-03	0.105771	0.338891	-0.404629	0.032208
2013-01-04	0.376774	-0.035958	-0.659694	0.261746
2013-01-05	0.317915	1.052522	-0.794585	1.480261
2013-01-06	0.579203	1.709605	-0.546063	0.336379
```

#### 직렬로 변환 할 수 있는 개체의 지시를 전달하여 DataFrame 만들기
```python
df2=pd.DataFrame({'A':1.,
                 'B':pd.Timestamp('20130102'),
                 'C':pd.Series(1, index=list(range(4)),dtype='float32'),
                 'D':np.array([3]*4,dtype='int32'),
                 'E':pd.Categorical(["test","train","test","train"]),
                 'F':'foo'})
df2

Out[6]:
A	B	C	D	E	F
0	1.0	2013-01-02	1.0	3	test	foo
1	1.0	2013-01-02	1.0	3	train	foo
2	1.0	2013-01-02	1.0	3	test	foo
3	1.0	2013-01-02	1.0	3	train	foo
```

#### DataFrame의 열은 다른 dtypes를 가진다.
```python
df2.dtypes

Out[7]:
A           float64
B    datetime64[ns]
C           float32
D             int32
E          category
F            object
dtype: object
```


## 3. 데이터 확인하기

#### 프레임의 상단과 하단 부분을 보기

```python
df.head()
df.tail(3) #하단부분 3열만 본다는 뜻

Out[8]:
A	B	C	D
2013-01-01	-1.313690	0.374085	0.143973	-0.624099
2013-01-02	-0.659125	-0.595977	0.403210	0.814707
2013-01-03	0.105771	0.338891	-0.404629	0.032208
2013-01-04	0.376774	-0.035958	-0.659694	0.261746
2013-01-05	0.317915	1.052522	-0.794585	1.480261
Out[8]:
A	B	C	D
2013-01-04	0.376774	-0.035958	-0.659694	0.261746
2013-01-05	0.317915	1.052522	-0.794585	1.480261
2013-01-06	0.579203	1.709605	-0.546063	0.336379
```

#### 인덱스와 상단 열 표시 (Index, Columns)
```python
df.index
df.columns

Out[9]:
DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',
               '2013-01-05', '2013-01-06'],
              dtype='datetime64[ns]', freq='D')
Out[9]:
Index(['A', 'B', 'C', 'D'], dtype='object')
```

DataFrame.to_numpy()는 기본 데이터의 NumPy표현을 제공합니다. DataFrame에 다른 데이터 유형의 열이 있는 경우 힘든 작업이 될 수 있습니다.
pandas와 NumPy의 근본적인 차이가 있습니다. Numpy 배열에는 전채 배열에 대한 하나의 dtype이 있는 반면, pandas의 DataFrames에는 각각의 열마다 각각의 dtype이 있습니다.

DataFrmae.to_numpy()를 불러오면 pandas는 DataFrame의 모든 dtype을 포함 할 수 있는 NumPy dtype을 찾습니다. object가 바로 모든 값을 아우를 수 있는 dtype이 될 수 있습니다.

모든 부동 소수점 값의 DataFrame인 df 경우 DataFrame.to_numpy()가 빠르며 데이터 복사가 필요하지 않습니다.
* DataFrame.to_numpy()는 index와 column 레이블을 포함하지 않습니다.
```python
df.to_numpy()
df.values

Out[10]:
array([[-1.31368999,  0.37408481,  0.14397347, -0.6240987 ],
       [-0.65912479, -0.59597727,  0.40321046,  0.81470747],
       [ 0.10577142,  0.33889057, -0.40462934,  0.03220843],
       [ 0.37677379, -0.03595848, -0.65969389,  0.26174625],
       [ 0.31791509,  1.05252188, -0.79458461,  1.48026149],
       [ 0.57920326,  1.70960542, -0.54606269,  0.33637945]])
Out[10]:
array([[-1.31368999,  0.37408481,  0.14397347, -0.6240987 ],
       [-0.65912479, -0.59597727,  0.40321046,  0.81470747],
       [ 0.10577142,  0.33889057, -0.40462934,  0.03220843],
       [ 0.37677379, -0.03595848, -0.65969389,  0.26174625],
       [ 0.31791509,  1.05252188, -0.79458461,  1.48026149],
       [ 0.57920326,  1.70960542, -0.54606269,  0.33637945]])
```       

#### df2의 DataFrame 은 여러 dtypes을 가지고 있다.
```python
df2.to_numpy()

Out[11]:
array([[1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'],
       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo'],
       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'],
       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo']],
      dtype=object)
```

#### describe() 는 데이터의 빠른 통계 요약을 보여준다.
```python
df.describe()

Out[12]:
A	B	C	D
count	6.000000	6.000000	6.000000	6.000000
mean	-0.098859	0.473861	-0.309631	0.383534
std	0.733660	0.811733	0.476770	0.713377
min	-1.313690	-0.595977	-0.794585	-0.624099
25%	-0.467901	0.057754	-0.631286	0.089593
50%	0.211843	0.356488	-0.475346	0.299063
75%	0.362059	0.882913	0.006823	0.695125
max	0.579203	1.709605	0.403210	1.480261
```

#### 열과 행을 바꾸기 원할 때 df.T를 씁니다.
```python
df.T

Out[13]:
2013-01-01 00:00:00	2013-01-02 00:00:00	2013-01-03 00:00:00	2013-01-04 00:00:00	2013-01-05 00:00:00	2013-01-06 00:00:00
A	-1.313690	-0.659125	0.105771	0.376774	0.317915	0.579203
B	0.374085	-0.595977	0.338891	-0.035958	1.052522	1.709605
C	0.143973	0.403210	-0.404629	-0.659694	-0.794585	-0.546063
D	-0.624099	0.814707	0.032208	0.261746	1.480261	0.336379
```

#### 축별 정렬
```python
df.sort_index(axis=1, ascending=False)

Out[14]:
D	C	B	A
2013-01-01	-0.624099	0.143973	0.374085	-1.313690
2013-01-02	0.814707	0.403210	-0.595977	-0.659125
2013-01-03	0.032208	-0.404629	0.338891	0.105771
2013-01-04	0.261746	-0.659694	-0.035958	0.376774
2013-01-05	1.480261	-0.794585	1.052522	0.317915
2013-01-06	0.336379	-0.546063	1.709605	0.579203
```

#### 값들 정렬
```python
df.sort_values(by='B')

Out[15]:
A	B	C	D
2013-01-02	-0.659125	-0.595977	0.403210	0.814707
2013-01-04	0.376774	-0.035958	-0.659694	0.261746
2013-01-03	0.105771	0.338891	-0.404629	0.032208
2013-01-01	-1.313690	0.374085	0.143973	-0.624099
2013-01-05	0.317915	1.052522	-0.794585	1.480261
2013-01-06	0.579203	1.709605	-0.546063	0.336379
```


## 4.선택

* 선택 및 설정을 위한 표준 Python/Numpy 표현은 직관적이며 양방향 작업, 프로덕션 코드 용으로 유용하지만 최적화 된 pandas 데이터 액세스 방법인 .at, .iat, .loc 및 .iloc을 권장합니다.

### 가져오기

#### df.A와 동등한 Series을 생성하는 단일 열 선택
```python
df['A'] #[열]Column

Out[16]:
2013-01-01   -1.313690
2013-01-02   -0.659125
2013-01-03    0.105771
2013-01-04    0.376774
2013-01-05    0.317915
2013-01-06    0.579203
Freq: D, Name: A, dtype: float64
```

#### [ ]을 통해 행을 선택합니다.
```python
df[0:3] #[행]Row
df['20130102':'20130104']

Out[17]:
A	B	C	D
2013-01-01	-1.313690	0.374085	0.143973	-0.624099
2013-01-02	-0.659125	-0.595977	0.403210	0.814707
2013-01-03	0.105771	0.338891	-0.404629	0.032208
Out[17]:
A	B	C	D
2013-01-02	-0.659125	-0.595977	0.403210	0.814707
2013-01-03	0.105771	0.338891	-0.404629	0.032208
2013-01-04	0.376774	-0.035958	-0.659694	0.261746
```

### 레이블에 따라 선택하기
#### 레이블에 의하여 값 얻기
```python
df.loc[dates[0]] #[행]

Out[18]:
A   -1.313690
B    0.374085
C    0.143973
D   -0.624099
Name: 2013-01-01 00:00:00, dtype: float64
```

#### 레이블 별로 다중 축 선택하기
```python
df.loc[:, ['A','B']] #[행,열]

Out[19]:
A	B
2013-01-01	-1.313690	0.374085
2013-01-02	-0.659125	-0.595977
2013-01-03	0.105771	0.338891
2013-01-04	0.376774	-0.035958
2013-01-05	0.317915	1.052522
2013-01-06	0.579203	1.709605
```

#### 레이블 슬라이싱
```python
df.loc['20130102':'20130104',['A','B']]

Out[20]:
A	B
2013-01-02	-0.659125	-0.595977
2013-01-03	0.105771	0.338891
2013-01-04	0.376774	-0.035958
```
```python
df.loc['20130102',['A','B']]

Out[21]:
A   -0.659125
B   -0.595977
Name: 2013-01-02 00:00:00, dtype: float64
```

#### 스칼라값 얻기
```python
df.loc[dates[0],'A']

Out[22]:
-1.313689989467988
```
스칼라값 빨리 얻기 (이전 방법과 동일)
```python
df.at[dates[0],'A']

Out[23]:
-1.313689989467988
```

### 위치에 의한 선택

#### 전달된 정수 위치를 통해 선택
```python
df.iloc[3]

Out[24]:
A    0.376774
B   -0.035958
C   -0.659694
D    0.261746
Name: 2013-01-04 00:00:00, dtype: float64
```

#### numpy/python과 유사한 interger slices
```python
df.iloc[3:5, 0:2]   #[행,열]

Out[25]:
A	B
2013-01-04	0.376774	-0.035958
2013-01-05	0.317915	1.052522
numpy/python 스타일과 비슷한 정수 위치 리스트
```
```python
df.iloc[[1,2,4],[0,2]]

Out[26]:
A	C
2013-01-02	-0.659125	0.403210
2013-01-03	0.105771	-0.404629
2013-01-05	0.317915	-0.794585
```

#### 행을 분할하기
```python
df.iloc[1:3,:]

Out[27]:
A	B	C	D
2013-01-02	-0.659125	-0.595977	0.403210	0.814707
2013-01-03	0.105771	0.338891	-0.404629	0.032208
```

#### 열을 분할하기
```python
df.iloc[:,1:3]

Out[28]:
B	C
2013-01-01	0.374085	0.143973
2013-01-02	-0.595977	0.403210
2013-01-03	0.338891	-0.404629
2013-01-04	-0.035958	-0.659694
2013-01-05	1.052522	-0.794585
2013-01-06	1.709605	-0.546063
```

#### 특정한 하나의 값 찾기
```python
df.iloc[1,1]

Out[29]:
-0.5959772742174114
```

#### 더 빠르게 스칼라 찾기 (전 방법과 동등)
```python
df.iat[1,1]

Out[30]:
-0.5959772742174114
```
### Boolean Indexing

#### 단일 열의 값을 사용하여 데이터를 선택하기
```python
df[df.A>0]

Out[31]:
A	B	C	D
2013-01-03	0.105771	0.338891	-0.404629	0.032208
2013-01-04	0.376774	-0.035958	-0.659694	0.261746
2013-01-05	0.317915	1.052522	-0.794585	1.480261
2013-01-06	0.579203	1.709605	-0.546063	0.336379
```
#### Boolean 조건이 충족되는 DataFrame에서 값을 선택합니다.
```python
df[df>0]

Out[32]:
A	B	C	D
2013-01-01	NaN	0.374085	0.143973	NaN
2013-01-02	NaN	NaN	0.403210	0.814707
2013-01-03	0.105771	0.338891	NaN	0.032208
2013-01-04	0.376774	NaN	NaN	0.261746
2013-01-05	0.317915	1.052522	NaN	1.480261
2013-01-06	0.579203	1.709605	NaN	0.336379
```

#### 필터링 기법인 isin() 방법 사용하기
```python
df2=df.copy()
df2['E']=['one','one','two','three','four','three']
df2
df2[df2['E'].isin(['two','four'])]

Out[33]:
A	B	C	D	E
2013-01-01	-1.313690	0.374085	0.143973	-0.624099	one
2013-01-02	-0.659125	-0.595977	0.403210	0.814707	one
2013-01-03	0.105771	0.338891	-0.404629	0.032208	two
2013-01-04	0.376774	-0.035958	-0.659694	0.261746	three
2013-01-05	0.317915	1.052522	-0.794585	1.480261	four
2013-01-06	0.579203	1.709605	-0.546063	0.336379	three
Out[33]:
A	B	C	D	E
2013-01-03	0.105771	0.338891	-0.404629	0.032208	two
2013-01-05	0.317915	1.052522	-0.794585	1.480261	four
```

### 설정하기
#### 새 열을 설정하면 데이터를 인덱스별로 자동 정렬합니다.
```python
s1=pd.Series([1,2,3,4,5,6],index=pd.date_range('20130102',periods=6))
s1
df['F']=s1

Out[34]:
2013-01-02    1
2013-01-03    2
2013-01-04    3
2013-01-05    4
2013-01-06    5
2013-01-07    6
Freq: D, dtype: int64
```

#### 레이블별 값 설정
```python
df.at[dates[0],'A']=0
```

#### 위치별 값 설정
```python
df.iat[0,1]=0
```

#### NumPy 배열을 지정하여 설정
```python
df.loc[:,'D']=np.array([5]*len(df))
```

#### 설정 작업 결과
```python
df

Out[38]:
A	B	C	D	F
2013-01-01	0.000000	0.000000	0.143973	5	NaN
2013-01-02	-0.659125	-0.595977	0.403210	5	1.0
2013-01-03	0.105771	0.338891	-0.404629	5	2.0
2013-01-04	0.376774	-0.035958	-0.659694	5	3.0
2013-01-05	0.317915	1.052522	-0.794585	5	4.0
2013-01-06	0.579203	1.709605	-0.546063	5	5.0
```

#### where 작동 설정하기
```python
df2=df.copy()
df2[df2>0]=-df2
df2

Out[39]:
A	B	C	D	F
2013-01-01	0.000000	0.000000	-0.143973	-5	NaN
2013-01-02	-0.659125	-0.595977	-0.403210	-5	-1.0
2013-01-03	-0.105771	-0.338891	-0.404629	-5	-2.0
2013-01-04	-0.376774	-0.035958	-0.659694	-5	-3.0
2013-01-05	-0.317915	-1.052522	-0.794585	-5	-4.0
2013-01-06	-0.579203	-1.709605	-0.546063	-5	-5.0
```
       
       
       
       
